name: Terraform (DEV) ‚Äî PR Plan & Protected Apply

on:
  pull_request:
    branches: [ main ]
    paths: [ 'dev/**' ]
  push:
    branches: [ main ]
    paths: [ 'dev/**' ]
  workflow_dispatch:
    inputs:
      target_ref:
        description: 'Branch or tag to check'
        required: true
        default: 'main'

env:
  TF_LOG: INFO
  TF_INPUT: false

# Prevent overlapping applies on the same env
concurrency:
  group: dev-terraform
  cancel-in-progress: false

jobs:
  pr-infra-check:
    # Run for PRs and manual runs (plan only)
    if: ${{ github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment:
      name: dev
    permissions:
      id-token: write
      contents: read
      pull-requests: write
      issues: write
    env:
      tf_actions_working_dir: ./dev
    defaults:
      run:
        shell: bash
        working-directory: ./dev
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.target_ref || github.ref }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: az account show
        run: az account show

      - name: Terraform Init
        id: init
        env:
          TF_STORAGE_ACCOUNT: ${{ secrets.TF_STORAGE_ACCOUNT }}
          TF_CONTAINER_NAME: ${{ secrets.TF_CONTAINER_NAME }}
          TF_RESOURCE_GROUP_NAME: ${{ secrets.TF_RESOURCE_GROUP_NAME }}
          TF_SUBSCRIPTION_ID: ${{ secrets.TF_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: >
          terraform init
          -backend-config="storage_account_name=$TF_STORAGE_ACCOUNT"
          -backend-config="container_name=$TF_CONTAINER_NAME"
          -backend-config="resource_group_name=$TF_RESOURCE_GROUP_NAME"
          -backend-config="subscription_id=$TF_SUBSCRIPTION_ID"

      - name: Terraform fmt
        id: fmt
        run: terraform fmt -check

      - name: Terraform validate
        id: validate
        if: success() || failure()
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          set -o pipefail
          terraform validate -no-color | tee validate.log
          {
            echo "stdout<<EOF"
            cat validate.log
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Terraform plan
        id: plan
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          set -o pipefail
          terraform plan -no-color | tee plan.log
          {
            echo "stdout<<EOF"
            cat plan.log
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Comment plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output =
              `#### Terraform Format and Style üñå  \`${{ steps.fmt.outcome }}\`
#### Terraform Initialization ‚öôÔ∏è  \`${{ steps.init.outcome }}\`
#### Terraform Validation ü§ñ
${{ steps.validate.outputs.stdout }}
#### Terraform Plan üìñ  \`${{ steps.plan.outcome }}\`

<details><summary>Show Plan</summary>

\`\`\`
${process.env.PLAN}
\`\`\`

</details>

*Pusher: @${{ github.actor }}, Action: ${{ github.event_name }}, Dir: ${{ env.tf_actions_working_dir }}, Workflow: ${{ github.workflow }}*`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

      - name: Show Plan Summary (manual)
        if: github.event_name == 'workflow_dispatch'
        run: |
          cat <<'EOF'
          Terraform Format: ${{ steps.fmt.outcome }}
          Terraform Init: ${{ steps.init.outcome }}
          Terraform Validate:
          ${{ steps.validate.outputs.stdout }}
          Terraform Plan: ${{ steps.plan.outcome }}
          Plan Output:
          ${{ steps.plan.outputs.stdout }}
          EOF

  apply:
    # Run only on push to main under dev/** with PR + checks gate
    if: ${{ github.event_name == 'push' }}
    runs-on: ubuntu-latest
    environment:
      name: dev
    permissions:
      id-token: write
      contents: read
      pull-requests: read
      checks: read
    defaults:
      run:
        shell: bash
        working-directory: ./dev
    steps:
      - name: Determine deployment eligibility
        id: pr-gate
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const commitSha = context.payload.after;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function result(payload) {
              return JSON.stringify(payload);
            }

            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner,
              repo,
              commit_sha: commitSha,
            });

            if (!prs.length) {
              core.notice(`No pull request found for commit ${commitSha}. Skipping deployment.`);
              return result({ proceed: false, reason: 'no_pr' });
            }

            const pr = prs.find(p => p.base?.ref === 'main') ?? prs[0];

            if (!pr.merged_at) {
              core.notice(`Pull request #${pr.number} is not merged. Skipping deployment.`);
              return result({ proceed: false, reason: 'not_merged', pr: pr.number });
            }

            const { data: reviews } = await github.rest.pulls.listReviews({
              owner,
              repo,
              pull_number: pr.number,
            });
            const approved = reviews.some(r => r.state === 'APPROVED');
            if (!approved) {
              core.notice(`Pull request #${pr.number} has no approving reviews. Skipping deployment.`);
              return result({ proceed: false, reason: 'not_approved', pr: pr.number });
            }

            const candidateRefs = Array.from(new Set([pr.head?.sha, pr.merge_commit_sha, commitSha].filter(Boolean)));
            let devCheck = null;
            for (const ref of candidateRefs) {
              const { data: checkRuns } = await github.rest.checks.listForRef({ owner, repo, ref });
              devCheck = checkRuns.check_runs?.find(run =>
                run.name === 'pr-infra-check' && run.conclusion === 'success'
              );
              if (devCheck) {
                core.info(`Found successful 'pr-infra-check' on ${ref}.`);
                break;
              }
            }
            if (!devCheck) {
              core.notice(`Required workflow 'pr-infra-check' did not complete successfully for commit ${commitSha}. Skipping deployment.`);
              return result({ proceed: false, reason: 'check_failed', pr: pr.number });
            }

            core.notice(`Deploying commit ${commitSha} from approved PR #${pr.number}.`);
            return result({ proceed: true, pr: pr.number });

      - name: Checkout
        if: ${{ fromJson(steps.pr-gate.outputs.result).proceed }}
        uses: actions/checkout@v4

      - name: Setup Terraform
        if: ${{ fromJson(steps.pr-gate.outputs.result).proceed }}
        uses: hashicorp/setup-terraform@v2

      - name: Azure login (OIDC)
        if: ${{ fromJson(steps.pr-gate.outputs.result).proceed }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform Init (backend)
        if: ${{ fromJson(steps.pr-gate.outputs.result).proceed }}
        env:
          TF_STORAGE_ACCOUNT: ${{ secrets.TF_STORAGE_ACCOUNT }}
          TF_CONTAINER_NAME: ${{ secrets.TF_CONTAINER_NAME }}
          TF_RESOURCE_GROUP_NAME: ${{ secrets.TF_RESOURCE_GROUP_NAME }}
          TF_SUBSCRIPTION_ID: ${{ secrets.TF_SUBSCRIPTION_ID }}
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: >
          terraform init
          -backend-config="storage_account_name=$TF_STORAGE_ACCOUNT"
          -backend-config="container_name=$TF_CONTAINER_NAME"
          -backend-config="resource_group_name=$TF_RESOURCE_GROUP_NAME"
          -backend-config="subscription_id=$TF_SUBSCRIPTION_ID"

      - name: Terraform Apply
        if: ${{ fromJson(steps.pr-gate.outputs.result).proceed }}
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        run: terraform apply -auto-approve
